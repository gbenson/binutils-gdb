Entry points:

cplus_demangle_v3
  - the one that the little test.c testcase I wrote enters
  - a one-line wrapper for d_demangle, which allocates a buffer

__cxa_demangle
  - a slightly more elaborate wrapper for d_demangle

__gcclibcxx_demangle_callback
  - THIS IS THE ALLOCATIONLESS ONE
  - it has a callback argument which gets called with
    demangled string segments


One level down:
  - d_demangle
    calls d_demangle_callback
    with d_growable_string_callback_adapter as its callback.

  - __gcclibcxx_demangle_callback
    calls d_demangle_callback
    with the callback it was provided by its caller.

So, d_demangle_callback is the common code that needs updating.

d_demangle_callback is static, so I can change its interface.

d_demangle_callback does not appear to call itself.
d_demangle_callback calls cplus_demangle_print_callback.

cplus_demangle_print_callback is NOT STATIC in some situations,
so presumably its interface cannot be changed.

cplus_demangle_print_callback also appears not to call itself.

cplus_demangle_print_callback:
 - initializes a struct d_print_info (on the stack)
 - calls d_print_comp with it (d_print_comp IS recursive)
 - tidies up

struct d_print_info is defined in cp-demangle.c, ie not a public
interface (awesome!)  struct d_print_info is also where the current
(allocated) array of scopes is stored.  Looks like the perfect
place to put a fixed-length array.

NB the example in test.c uses 3 d_saved_scopes and 5 d_print_templates.

---

There is one place where scopes are saved: in d_print_comp,
for case DEMANGLE_COMPONENT_REFERENCE
and case DEMANGLE_COMPONENT_RVALUE_REFERENCE
iff (sub->type == DEMANGLE_COMPONENT_TEMPLATE_PARAM
     AND THE SCOPE HAS NOT ALREADY BEEN SAVED)

---

d_demangle_callback knows:
 - the mangled symbol (and therefore its length)
 - the number of comp(onent)s it used
 - the number of sub(tree)s it used

These numbers cannot be passed to cplus_demangle_print_callback
without changing the interface.

cplus_demangle_print_callback can't know the number of components
without walking the tree... so duplicating the tree walk?

What calls d_print_comp?
[- cplus_demangle_print_callback (obviously)]
 - d_print_subexpr (starts on line 4048)
 - d_print_comp
 - d_print_mod_list
 - d_print_mod
 - d_print_function_type
 - d_print_array_type
 - d_print_expr_op
 - d_print_cast (ends on line 5607)
These guys are the tree walk... a lot of code :(

---

d_demangle_callback allocates 846 comps and 423 subs,
that's 20304 and 3384 bytes respectively.

XXX_shizzle counted 7 scopes and 1906 temps (and 393 comps),
which would be 112 and 15248 bytes respectively.

Already allocated: 20304 + 3384 = 23688
Extra:              112 + 15248 = 15360
                                  -----
				  39048

Conclusions:
  - This way of counting requires a smaller but comparable amount
    of (extra) stack for this particular symbol.
  - This would likely be tight on a 64k stack.

---

Take 2: XXX_shizzle counted 3 scopes and 565 templates,
which would be 48 and 4520 bytes respectively (4568 total),
with the already allocated 23688 + 4568 = 28256 bytes.
Oh!, or 14128 bytes on a 32-bit machine.
