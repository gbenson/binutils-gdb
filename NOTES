Entry points:

cplus_demangle_v3
  - the one that the little test.c testcase I wrote enters
  - a one-line wrapper for d_demangle, which allocates a buffer

__cxa_demangle
  - a slightly more elaborate wrapper for d_demangle

__gcclibcxx_demangle_callback
  - THIS IS THE ALLOCATIONLESS ONE
  - it has a callback argument which gets called with
    demangled string segments


One level down:
  - d_demangle
    calls d_demangle_callback
    with d_growable_string_callback_adapter as its callback.

  - __gcclibcxx_demangle_callback
    calls d_demangle_callback
    with the callback it was provided by its caller.

So, d_demangle_callback is the common code that needs updating.

d_demangle_callback is static, so I can change its interface.

d_demangle_callback does not appear to call itself.
d_demangle_callback calls cplus_demangle_print_callback.

cplus_demangle_print_callback is NOT STATIC in some situations,
so presumably its interface cannot be changed.

cplus_demangle_print_callback also appears not to call itself.

cplus_demangle_print_callback:
 - initializes a struct d_print_info (on the stack)
 - calls d_print_comp with it (d_print_comp IS recursive)
 - tidies up

struct d_print_info is defined in cp-demangle.c, ie not a public
interface (awesome!)  struct d_print_info is also where the current
(allocated) array of scopes is stored.  Looks like the perfect
place to put a fixed-length array.

NB the example in test.c uses 3 d_saved_scopes and 5 d_print_templates.

---

There is one place where scopes are saved: in d_print_comp,
for case DEMANGLE_COMPONENT_REFERENCE
and case DEMANGLE_COMPONENT_RVALUE_REFERENCE
iff (sub->type == DEMANGLE_COMPONENT_TEMPLATE_PARAM
     AND THE SCOPE HAS NOT ALREADY BEEN SAVED)

---

d_demangle_callback knows:
 - the mangled symbol (and therefore its length)
 - the number of comp(onent)s it used
 - the number of sub(tree)s it used

These numbers cannot be passed to cplus_demangle_print_callback
without changing the interface.

cplus_demangle_print_callback can't know the number of components
without walking the tree... so duplicating the tree walk?

What calls d_print_comp?
[- cplus_demangle_print_callback (obviously)]
 - d_print_subexpr (starts on line 4048)
 - d_print_comp
 - d_print_mod_list
 - d_print_mod
 - d_print_function_type
 - d_print_array_type
 - d_print_expr_op
 - d_print_cast (ends on line 5607)
These guys are the tree walk... a lot of code :(
