 1. readline works like this:

    * The internal function rl_completion_matches() uses an
      application-supplied "generator" function to generate the list of
      possible matches, and then returns the array of these matches.
      The caller should place the address of its generator function in
      rl_completion_entry_function.

    * The generator function is called repeatedly from
      rl_completion_matches(), returning a string each time.  The
      arguments to the generator function are TEXT and STATE.  TEXT is
      the partial word to be completed.  STATE is zero the first time
      the function is called, allowing the generator to perform any
      necessary initialization, and a positive non-zero integer for
      each subsequent call.  The generator function returns NULL to
      inform rl_completion_matches() that there are no more
      possibilities left.  Usually the generator function computes the
      list of possible completions when STATE is zero, and returns them
      one at a time on subsequent calls.  Each string the generator
      function returns as a match must be allocated with malloc();
      readline frees the strings when it has finished with them.  Such
      a generator function is referred to as an "application-specific
      completion function".

    -> "readline frees the strings when it has finished with them" oh my

 2. readline setup happens in init_main(), in gdb/top.c, notably:

      rl_completion_entry_function = readline_line_completion_function;

    readline_line_completion_function() is just a wrapper for
    line_completion_function() that adds a little more state.

 3. line_completion_function() unwraps the generator paradigm.  The
    first time it's called it calls complete_line() to generate all
    possible completions.  A comment in line_completion_function()
    says that complete_line() may abort by calling error().
    complete_line() is a wrapper for complete_line_internal().

 4. complete_line_internal() marshals the call into one of many
    specific completers:

      gdb/completer.c:      noop_completer
      gdb/completer.c:      filename_completer
      gdb/completer.c:      location_completer
      gdb/completer.c:      expression_completer
      gdb/completer.c:      command_completer
      gdb/completer.c:      signal_completer

      gdb/breakpoint.c:     catch_syscall_completer
      gdb/breakpoint.c:     condition_completer
      gdb/cli/cli-decode.c: integer_unlimited_completer
      gdb/cli/cli-decode.c: set_cmd_completer
      gdb/cp-abi.c:         cp_abi_completer
      gdb/infrun.c:         handle_completer
      gdb/interps.c:        interpreter_completer
      gdb/python/py-cmd.c:  cmdpy_completer
      gdb/remote-sim.c:     sim_command_completer

      ...and more in symtab.c

    The one that's slow for "b <Tab>" is location_completer().

 5. The bit that's slow is make_symbol_completion_list(), but
    (XXX!) note the above make_file_symbol_completion_list()
    which may also be slow (but probably not *so* slow!).

 6. make_symbol_completion_list() is called from a few different
    places.  location_completer() is the only function that calls
    make_file_symbol_completion_list().

 7. make_symbol_completion_list() marshals the call into a
    language-specific completer.  For LibreOffice "b <Tab>"
    this is default_make_symbol_completion_list(), which is a
    wrapper for default_make_symbol_completion_list_break_on().

    7. a) gdb /usr/lib64/libreoffice/program/soffice.bin
          start
          b <Tab>

 8. default_make_symbol_completion_list_break_on() calls
    expand_partial_symbol_names().  This is (likely) the bit
    where we vanish into the nothing.  Note that there is a
    cleanup set across this call, so we could potentially use
    error() to abort long calls (by count or by elapsed time).

 9. Note that LibreOffice "b <Tab><Tab>" has 178974 possibilities.

10. Note also https://sourceware.org/bugzilla/show_bug.cgi?id=11920:

      Example from a c++ program:

      (gdb) break std::<tab>
      [...nothing for about 3 seconds - not obviously killable...]
      Display all 14472 possibilities? (y or n)

11. Note also also that it is the first <Tab> which is slow, but
    the second <Tab> which prints a newline (and some other stuff)
    so I don't *think* we could print a progress report.

12. expand_partial_symbol_names() enters 93 objfiles for the LibreOffice
    case.  The speed it does this would make it great for a progress
    update.  The function it enters them with (objfile->sf->qf->
    expand_symtabs_matching) is set to expand_symtabs_matching_via_partial():

    - file_matcher is NULL,
    - name_matcher is expand_partial_symbol_name().

    For this case, expand_symtabs_matching_via_partial() calls
    recursively_search_psymtabs() to decide whether to perform
    the expansion.  This is what calls expand_partial_symbol_name()
    (4321 times for the LibreOffice case).  Then (for every
    psymtab in this case) psymtab_to_symtab() is called.

13. Some version of the number of symbols is visible here, albeit
    inflated with duplicates.  Totalling ps->n_global_syms and
    ps->n_static_syms over the LibreOffice "b <Tab>" case gives
    110999 global and 422421 static (eventually resulting in 178974
    possibilities, as noted above).

    Note that this code path is only entered the first time you do
    "b <Tab>".

14. Note that objfile->sf->qf->expand_symtabs_matching (and hence
    expand_symtabs_matching_via_partial) is called from various
    places:

      gdb/psymtab.c:       objfile->sf->qf->expand_symtabs_matching
      gdb/symmisc.c:	   objfile->sf->qf->expand_symtabs_matching
      gdb/linespec.c:	   objfile->sf->qf->expand_symtabs_matching
      gdb/symfile-debug.c: debug_data->real_sf->qf->expand_symtabs_matching
      gdb/symtab.c:        objfile->sf->qf->expand_symtabs_matching

15. IRC conversation (abridged and edited):

       <gbenson> fwiw I've some half-finished code to cause
                 the completer to stop after N symbols
       <gbenson> I imagined having some user-settable limit,
                 say 1000 completions
      <pmuldoon> I think 100
      <pmuldoon> Not going to look through a 1000 symbols
        <palves> what happens when the limit is hit?
                 beep, and let the user type more characters
                 to disambiguate?
       <gbenson> it's pretty dirty at the moment, it just
                 calls error() and halts the completer
        <palves> I'd expect to not lose what I was typing :-)

16. Note that some kind of progress indicator is a probably red
    herring as there is no utility in building a giant list of
    completions--nobody is going to bother scrolling through a
    huge list.

17. When you're in there, it looks like this:

      default_make_symbol_completion_list_break_on  gdb/symtab.c:4289
      default_make_symbol_completion_list           gdb/symtab.c:4512
      make_symbol_completion_list                   gdb/symtab.c:4522
      location_completer                            gdb/completer.c:268
      complete_line_internal                        gdb/completer.c:682
      complete_line                                 gdb/completer.c:777
      line_completion_function                      gdb/completer.c:878
      readline_line_completion_function             gdb/completer.c:102
      rl_completion_matches                         readline/complete.c:1997
      ...

18. To test for big lists without entering location_completer,
    try "source ~/.dslwatch/13771/<Tab><Tab>".

19. It IS a problem that the signal for too many completions (beep,
    print nothing) is the same as the signal for no completions.
